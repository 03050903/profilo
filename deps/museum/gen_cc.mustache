// Copyright 2004-present Facebook. All Rights Reserved.
// Generated by: //native/museum/run_codegen.sh
// This is generated code -- do not modify manually.

// @{{!.}}generated SignedSource<<00000000000000000000000000000000>>
// @model md5 {{{modelHash}}}

{{!
This is the model for the mappings between Museum's headers and ART's method implementations.
This will be used to generate "implementations" of the header-declared methods and globals,
which in reality will simply look up the actual implementations in libart.so and delegate
calls to the real versions.

YAML reference: http://www.yaml.org/refcard.html

=== Schema ===
(file)
  headers           => string[]             Required        List of headers to include in generated cpp
  classes           => class_spec[]         Required        Root of definition hierarchy

(class_spec)
  className         => string               Nullable        Class name for subsequent set of symbols
  symbols           => symbol_spec[]        Required        Set of symbols defined by particular class

(symbol_spec)
  symbolName        => string               Required        Name of the symbol (method or static field)
  params            => string[]             Optional        Omit if no-param method, dtor, or static field
  returnType        => string               Optional        Omit if ctor. Use "void" if void method.
  mangledNames      => string[]             Required        List of raw mangled names in DSO.
  cvFlags           => string               Optional        const/volatile modifiers of method
  isStaticVar       => boolean              Optional        true if static field or global
  skipMethodWrap    => boolean              Optional        true to skip method-wrapping check (you don't need
                                                              this.. mostly a workaround for Runtime::Current
                                                              that doesn't quite perfectly fit the pattern)
}}

{{#headers}}
#include <{{{.}}}>
{{/headers}}

#include <museum/libart.h>

{{#classes}}
{{#symbols}}
{{#conditional}}#if {{{.}}}{{/conditional}}
namespace facebook { namespace museum { namespace art { namespace detail {
  template<typename T>
  T* lookup_{{#mangledNames}}_{{{.}}}{{/mangledNames}}() {
    static auto const symbol = ::facebook::libart().get_symbol<T>({
      {{#mangledNames}}"{{{.}}}",{{/mangledNames}}
    });
    return symbol;
  }
} } } } // namespace facebook::museum::art::detail
namespace art {
{{#isStaticVar}}{{^skipMethodWrap}}#ifdef {{{symbolName}}}
  #undef {{{symbolName}}}
#else
  #error "{{{symbolName}}} is not method-wrapped and will not be proxied correctly"
#endif{{/skipMethodWrap}}{{/isStaticVar}}
  {{{returnType}}} {{#className}}{{{.}}}::{{/className}}{{{symbolName}}}({{#params}}{{{type}}} p{{{idx}}}, {{/params}}) {{{cvFlags}}} {
    {{#returnType}}return{{#isStaticVar}} *{{/isStaticVar}}{{/returnType}}
      ::facebook::museum::art::detail::lookup_{{#mangledNames}}_{{{.}}}{{/mangledNames}}
      <{{{returnType}}}{{^returnType}}void{{/returnType}}
        {{^isStaticVar}}({{#className}}{{{.}}} {{{cvFlags}}}*, {{/className}}{{#params}}{{{type}}}, {{/params}}){{/isStaticVar}}>()
      {{^isStaticVar}}({{#className}}this, {{/className}}{{#params}}p{{{idx}}}, {{/params}}){{/isStaticVar}};
  }
} // namespace art
{{#conditional}}#endif{{/conditional}}
{{/symbols}}
{{/classes}}

namespace facebook { namespace museum { namespace art {
using namespace ::art;
void preinitSymbols() {
{{#classes}}{{#symbols}}
{{#conditional}}#if {{{.}}}{{/conditional}}
  ::facebook::museum::art::detail::lookup_{{#mangledNames}}_{{{.}}}{{/mangledNames}}
    <{{{returnType}}}{{^returnType}}void{{/returnType}}
      {{^isStaticVar}}({{#className}}{{{.}}} {{{cvFlags}}}*, {{/className}}{{#params}}{{{type}}}, {{/params}}){{/isStaticVar}}>();
{{#conditional}}#endif{{/conditional}}
{{/symbols}}{{/classes}}
}
} } } // namespace facebook::museum::art
